{
    "contents" : "library(shiny)\nlibrary(datasets)\nlibrary(rattle)\n# Define server logic required to summarize and view the selected dataset\nshinyServer(\n  function(input, output) {\n  \n#   # By declaring datasetInput as a reactive expression we ensure that:\n#   #\n#   #  1) It is only called when the inputs it depends on changes\n#   #  2) The computation and result are shared by all the callers (it \n#   #     only executes a single time)\n#   #\n#   datasetInput <- reactive({\n#     switch(input$dataset,\n#            \"rock\" = rock,\n#            \"pressure\" = pressure,\n#            \"cars\" = cars)\n#   })\n#   \n#   # The output$caption is computed based on a reactive expression that\n#   # returns input$caption. When the user changes the \"caption\" field:\n#   #\n#   #  1) This expression is automatically called to recompute the output \n#   #  2) The new caption is pushed back to the browser for re-display\n#   # \n#   # Note that because the data-oriented reactive expressions below don't \n#   # depend on input$caption, those expressions are NOT called when \n#   # input$caption changes.\n#   output$caption <- renderText({\n#     input$caption\n#   })\n#   \n#   # The output$summary depends on the datasetInput reactive expression, \n#   # so will be re-executed whenever datasetInput is invalidated\n#   # (i.e. whenever the input$dataset changes)\n#   output$summary <- renderPrint({\n#     dataset <- datasetInput()\n#     summary(dataset)\n#   })\n#   \n#   # The output$view depends on both the databaseInput reactive expression\n#   # and input$obs, so will be re-executed whenever input$dataset or \n#   # input$obs is changed. \n#   output$view <- renderTable({\n#     head(datasetInput(), n = input$obs)\n#   })\n    # This function essentially takes inputs relayed from the used and creates a data frame to predict on\n    # using the model computed using the training dataset.\n    f <- function(prevclsr, gender, race, appleduc, majorimp, applwork, applearn, applhour) \n      {\n        if (race==\"white\") {\n          newRow <- data.frame(prevclsr,gender,white=as.factor(1),black=as.factor(0),aian=as.factor(0),asian=as.factor(0),nhpi=as.factor(0),appleduc,majorimp,applwork,applearn,applhour)  \n        } else if (race==\"black\") {\n          newRow <- data.frame(prevclsr,gender,white=as.factor(0),black=as.factor(1),aian=as.factor(0),asian=as.factor(0),nhpi=as.factor(0),appleduc,majorimp,applwork,applearn,applhour)\n        } else if (race==\"aian\") {\n          newRow <- data.frame(prevclsr,gender,white=as.factor(0),black=as.factor(0),aian=as.factor(1),asian=as.factor(0),nhpi=as.factor(0),appleduc,majorimp,applwork,applearn,applhour)\n        } else if (race==\"asian\") {\n          newRow <- data.frame(prevclsr,gender,white=as.factor(0),black=as.factor(0),aian=as.factor(0),asian=as.factor(1),nhpi=as.factor(0),appleduc,majorimp,applwork,applearn,applhour)\n        } else if (race==\"nhpi\") {\n          newRow <- data.frame(prevclsr,gender,white=as.factor(0),black=as.factor(0),aian=as.factor(0),asian=as.factor(0),nhpi=as.factor(1),appleduc,majorimp,applwork,applearn,applhour)\n        }\n        \n        results <- predict(modFitRpart,newdata=newRow)\n        as.character(results[1])\n      }\n    \n    # By declaring output as a reactive expression we ensure that:\n    #\n    #  1) It is only called when the inputs it depends on changes\n    #  2) The computation and result are shared by all the callers (it \n    #     only executes a single time)\n    x <- reactive(\n          {\n            f(input$prevclsr,input$gender,input$race,input$appleduc,input$majorimp,input$applwork,input$applearn,input$applhour)\n          }\n        )\n    \n    # The output$result is computed based on a reactive expression that\n    # returns input$result When the user changes any of the input parameters field:\n    #\n    #  1) This expression is automatically called to recompute the output \n    #  2) The new caption is pushed back to the browser for re-display\n    output$result <- renderText({x()})\n    \n    # This is a static display of the graph that was computed using the training data set\n    output$newDecisionTree <- renderPlot({\n      fancyRpartPlot(modFitRpart$finalModel)\n    })\n  }\n)",
    "created" : 1411221881737.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2470408869",
    "id" : "98AE357F",
    "lastKnownWriteTime" : 1411231505,
    "path" : "~/GitHub/Badger/server.R",
    "project_path" : "server.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}